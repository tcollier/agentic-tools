# Guide for AI Agents

This document provides instructions for AI agents (like Claude Code) working in this repository.

## Issue Tracking with Beads

This repository uses **[Beads](https://github.com/beadified/beads)** for issue tracking instead of traditional tools like GitHub Issues or Jira.

### What is Beads?

Beads is a local-first, git-based issue tracker that stores issues as JSONL files alongside your code. Issues are tracked in the `.beads/` directory and automatically sync with version control.

### Key Commands

```bash
# List all issues
bd list

# List issues by status
bd list --status open
bd list --status in_progress
bd list --status blocked
bd list --status closed

# Show detailed information about an issue
bd show <issue-id>

# Create a new issue
bd create "Issue title" --type <bug|feature|task|epic|chore> --priority <0-4>

# Update issue status
bd update <issue-id> --status <open|in_progress|blocked|closed>

# Update other fields
bd update <issue-id> --assignee "name@example.com"
bd update <issue-id> --priority 1
```

### JSON Output

Most commands support `--json` flag for programmatic access:

```bash
bd list --status open --json
bd show <issue-id> --json
```

## **CRITICAL RULE: Atomic Commits**

When an AI agent fixes an issue tracked in Beads:

### ✅ Required Workflow

1. Make the code changes to fix the issue
2. Mark the corresponding bead as completed: `bd update <issue-id> --status closed`
3. **Include both code changes AND `.beads/` changes in the same commit**

Example:
```bash
# Fix the bug in code
# ... make your changes ...

# Mark the issue as closed
bd update agentic-tools-abc --status closed

# Commit everything together
git add src/my-file.js .beads/
git commit -m "Fix authentication timeout issue

Implemented exponential backoff for authentication retry logic.

Closes: agentic-tools-abc"
```

### ❌ Anti-Pattern (DO NOT DO THIS)

**Never split code changes and issue updates into separate commits:**

```bash
# BAD: Don't do this
git add src/my-file.js
git commit -m "Fix auth issue"

# Then separately
bd update agentic-tools-abc --status closed
git add .beads/
git commit -m "Mark issue as closed"
```

### Why This Matters

Keeping code changes and issue closure in the same commit ensures:

1. **Traceability**: The commit that fixes the issue clearly shows which issue was resolved
2. **Atomicity**: Changes and their tracking metadata stay synchronized
3. **Reversibility**: Reverting a commit also reverts the issue status change
4. **Clarity**: Code review shows both what changed and what issue was addressed
5. **History**: Git history accurately reflects when issues were actually resolved

## Issue Workflow for AI Agents

### When Starting Work on an Issue

1. **Check current status:**
   ```bash
   bd show <issue-id> --json
   ```

2. **Mark as in progress:**
   ```bash
   bd update <issue-id> --status in_progress
   ```

3. **Commit the status change:**
   ```bash
   git add .beads/
   git commit -m "Start work on <issue-id>: <issue-title>"
   ```

### When Completing an Issue

1. **Make all necessary code changes**
2. **Mark issue as closed:**
   ```bash
   bd update <issue-id> --status closed
   ```

3. **Commit code changes AND issue closure together:**
   ```bash
   git add <changed-files> .beads/
   git commit -m "Implement <feature-name>

   <Description of changes>

   Closes: <issue-id>"
   ```

### When Blocked

If you encounter a blocker:

```bash
bd update <issue-id> --status blocked
git add .beads/
git commit -m "Block <issue-id>: waiting for <reason>"
```

## Viewing the Issue Summary

A human-readable summary of all issues is maintained in `BEADS.md`:

- This file is auto-generated by `ext/beads/generate-beads-summary.sh`
- It's updated automatically via git pre-commit hook
- **Do not edit BEADS.md manually** - it will be overwritten

To manually regenerate:
```bash
./ext/beads/generate-beads-summary.sh
```

## Finding Issues to Work On

### List Open Issues
```bash
bd list --status open
```

### Find High-Priority Issues
```bash
bd list --status open --json | jq '.[] | select(.priority <= 1)'
```

### Search by Type
```bash
# Find bugs
bd list --json | jq '.[] | select(.issue_type == "bug" and .status == "open")'

# Find features
bd list --json | jq '.[] | select(.issue_type == "feature" and .status == "open")'
```

## Issue Types

- **bug**: Something is broken and needs fixing
- **feature**: New functionality to be added
- **task**: General work item or improvement
- **epic**: Large body of work that may spawn multiple issues
- **chore**: Maintenance work (dependencies, tooling, cleanup)

## Priority Levels

- **P0** (0): Critical, blocks major functionality
- **P1** (1): High priority, important for current milestone
- **P2** (2): Medium priority, should be addressed soon
- **P3** (3): Low priority, nice to have
- **P4** (4): Very low priority, backlog item

## Best Practices for AI Agents

1. **Always check for related issues** before creating new ones
2. **Include issue IDs in commit messages** using "Closes: issue-id" or "Relates to: issue-id"
3. **Update issue status atomically** with code changes
4. **Add acceptance criteria** when creating issues to clarify success conditions
5. **Use appropriate issue types** to help with prioritization and categorization
6. **Set realistic priorities** - not everything is P0
7. **Add context in descriptions** - future agents (and humans) will thank you

## Example: Complete Workflow

Here's a full example of an AI agent working on an issue:

```bash
# 1. Find an issue to work on
bd list --status open --json | jq '.[] | select(.priority <= 1) | {id, title, priority}'

# Output: agentic-tools-xyz - "Add rate limiting to API endpoints" (P1)

# 2. Mark it as in progress
bd update agentic-tools-xyz --status in_progress
git add .beads/
git commit -m "Start work on agentic-tools-xyz: Add rate limiting to API endpoints"

# 3. Make code changes
# ... implement rate limiting ...

# 4. Mark as closed and commit everything together
bd update agentic-tools-xyz --status closed
git add src/api/middleware/rate-limiter.js src/api/middleware/index.js .beads/
git commit -m "Add rate limiting middleware to API endpoints

Implement token bucket algorithm for rate limiting:
- 100 requests per minute per IP
- Configurable limits via environment variables
- Returns 429 status when limit exceeded
- Adds X-RateLimit headers to responses

Closes: agentic-tools-xyz"
```

## Troubleshooting

### Issue Not Updating

If `bd update` doesn't seem to work:
```bash
# Check if daemon is running
bd sync --flush-only

# Verify the change
bd show <issue-id> --json | jq '.status'
```

### .beads/ Directory Issues

If `.beads/` changes aren't appearing:
```bash
# Check git status
git status

# The .beads/ directory should show as modified
# If not, ensure beads daemon synced:
bd sync --flush-only
```

### Finding Issue IDs

Issue IDs follow the pattern: `{repo-prefix}-{short-hash}`

Example: `agentic-tools-abc`, `agentic-tools-xyz`

List all IDs:
```bash
bd list --json | jq -r '.[].id'
```

## Resources

- **Beads Documentation**: [GitHub](https://github.com/beadified/beads)
- **BEADS.md**: Auto-generated summary of all issues in this repo
- **ext/beads/README.md**: Additional beads setup documentation for this repo

---

<!-- BEGIN: Stage-Specific Criteria (Auto-generated by /configure-agents) -->
## Stage-Specific Development Criteria

**Company Stage:** 4. Early Scaling
**Last Updated:** 2025-11-11T18:50:00Z

*This section is automatically generated based on your company stage configuration. To update after a stage change, run `/configure-agents` again.*

---

### Stage 4 Overview

**Revenue:** $100K-$1M MRR
**Team Size:** 15-50 people
**Key Signal:** Scaling infrastructure

At Stage 4 (Early Scaling), you have product-market fit and are scaling your infrastructure to support growth. You're moving from "does it work?" to "does it scale?" The team is large enough that code quality and architecture matter significantly. You need good observability to understand system behavior and automated processes to maintain velocity.

---

### Development Priorities at Stage 4

#### ✅ Critical (Must Have)

These items are non-negotiable for Stage 4:

- **All P0 + most P1 items** from the essential criteria
- Good architecture that can scale
- Performance monitoring to catch bottlenecks
- Automated deployments to ship safely and quickly
- On-call rotations for production support
- Comprehensive testing (60-80% coverage goal)
- Proper error handling and logging throughout
- Security basics firmly in place

#### ⏸️ What Doesn't Matter Yet

At Stage 4, intentionally skip or deprioritize:

- Perfect cost optimization (growth > efficiency)
- 100% test coverage (diminishing returns)
- Paying down all technical debt (strategic debt is okay)
- Extensive performance tuning (unless it's blocking scale)

**Remember:** You're scaling, so invest in infrastructure, monitoring, and automation. But don't over-optimize - you're still learning what scale really means for your product.

---

### Essential Development Criteria

Apply these criteria with Stage 4-appropriate rigor:

#### 1. Version Control
- Git repository initialized ✅
- .gitignore configured for language/framework ✅
- Meaningful commit history ✅
- No secrets or sensitive data in repository ✅
- Branch protection rules on main/production branches
- Pull request reviews required

**Stage 4 Focus:** Version control is table stakes. Focus on PR review processes and branch protection to maintain quality as the team scales.

#### 2. Testing & Quality
- Testing framework configured ✅
- Unit tests for core functionality ✅
- Integration tests for critical paths ✅
- Test coverage reporting available ✅
- Tests run successfully ✅
- **60-80% test coverage goal**
- Automated test runs in CI/CD

**Stage 4 Focus:** Comprehensive testing is critical. You need confidence to ship quickly without breaking things. Focus on testing critical paths and business logic thoroughly.

#### 3. Error Handling & Logging
- Proper error handling throughout codebase ✅
- User-friendly error messages ✅
- Logging configured (not just console.log/print) ✅
- **Error reporting/monitoring setup (required)**
- Structured logging with context
- Log aggregation and search capability
- Error alerts for critical failures

**Stage 4 Focus:** Production-grade logging and error tracking are essential. You need to understand failures quickly to maintain system reliability.

#### 4. Documentation
- README with project overview ✅
- Setup/installation instructions ✅
- Usage examples ✅
- API documentation (if applicable) ✅
- Code comments for complex logic ✅
- Contributing guidelines ✅
- **Architecture documentation (ARCHITECTURE.md or similar)**
- Runbooks for common operations
- Onboarding docs for new engineers

**Stage 4 Focus:** Documentation helps new team members ramp up quickly. Invest in architecture docs and operational runbooks.

#### 5. Configuration Management
- Environment variables for configuration ✅
- .env.example or similar template ✅
- No hardcoded credentials or secrets ✅
- Separate dev/staging/prod configurations ✅
- Secrets management system (Vault, AWS Secrets Manager, etc.)
- Config validation on startup

**Stage 4 Focus:** Proper secrets management is required. Hardcoded credentials or .env files in production are unacceptable.

#### 6. Code Quality
- Consistent code style ✅
- Linter configured ✅
- Formatter configured ✅
- No unused imports or dead code ✅
- Reasonable function/file sizes ✅
- Code review process enforced
- Pre-commit hooks for linting/formatting

**Stage 4 Focus:** Code quality tools should be automated and enforced. Don't rely on manual reviews to catch formatting issues.

#### 7. Security
- Dependencies scanned for vulnerabilities ✅
- Input validation on user inputs ✅
- Authentication/authorization if needed ✅
- HTTPS in production ✅
- Security headers configured ✅
- **Regular security audits**
- Dependency update process
- Security incident response plan

**Stage 4 Focus:** Security must be proactive. Regular dependency updates and vulnerability scanning are required. Have a plan for security incidents.

#### 8. Dependencies
- Dependencies locked ✅
- Only necessary dependencies included ✅
- Regular dependency updates plan ✅
- **Automated dependency updates (Dependabot, Renovate)**
- License compliance checking
- Vulnerability scanning in CI/CD

**Stage 4 Focus:** Automate dependency management. Manual updates don't scale with team growth.

#### 9. Build & Deployment
- Build process documented ✅
- **CI/CD pipeline (required)**
- Deployment instructions ✅
- Health check endpoint ✅
- Graceful shutdown handling ✅
- **Automated deployments**
- Blue/green or canary deployments
- Rollback procedures documented and tested

**Stage 4 Focus:** Deployment automation is essential. Manual deployments are too risky and slow at this stage.

#### 10. Monitoring & Observability
- Application logging ✅
- **Performance monitoring (required)**
- **Alerting configured (required)**
- Metrics collection ✅
- **APM (Application Performance Monitoring)**
- Dashboards for key metrics
- SLIs (Service Level Indicators) defined
- On-call rotation established

**Stage 4 Focus:** You must understand system behavior in production. Invest heavily in monitoring, alerting, and observability tools.

---

### AI Agent Development Guidelines

**Priority at Stage 4:** P1 (Should have)

AI coding agents (like Claude Code) work best when codebases are clear and well-structured. Here's what matters for Stage 4:

**Documentation:**
- Clear README with project overview and architecture
- ARCHITECTURE.md explaining system design
- CONTRIBUTING.md with development workflow
- Clear module/component descriptions
- API documentation for all public interfaces

**Code Clarity:**
- Descriptive function and variable names (avoid abbreviations)
- Consistent coding patterns and conventions
- Comments on complex logic and non-obvious decisions
- Type hints/annotations (TypeScript, Python type hints, etc.)
- Prefer readable code over clever code

**Structure:**
- Logical file and directory organization
- Clear separation of concerns
- Consistent naming conventions across codebase
- Well-organized imports/dependencies
- Modular architecture

**Testing:**
- Good test coverage (helps agents understand expected behavior)
- Test names that describe what they're testing
- Example usage in tests
- Integration tests for critical workflows

**Context:**
- Clear error messages that explain what went wrong
- Comments explaining "why" not just "what"
- Documentation of architectural decisions
- .clinerules or similar for AI-specific instructions (optional but helpful)

At Stage 4, AI agent readiness significantly improves developer productivity. Invest in code clarity and documentation.

---

### Technical Design Quality Expectations

At Stage 4, technical designs should be:

**Comprehensive Design (3-5 pages):**
- All sections present and detailed
- Testing strategy (60-80% coverage goal)
- Monitoring and observability plan
- Security considerations addressed
- Performance requirements specified
- Rollout strategy defined
- **Always include "What NOT to Build" section**

**Required sections:**
- Overview and context
- Technical approach
- What to build (detailed)
- Testing strategy (comprehensive)
- Deployment plan
- Monitoring & observability
- Security considerations
- Performance approach
- Rollout strategy
- What NOT to build

**Should address:**
- Scale expectations and growth projections
- Error handling and recovery
- Database schema and indexes
- API design and versioning (if applicable)
- Caching strategy (if needed)
- Background job processing (if needed)

**Design Quality Markers:**
- Specific, not vague (actual file names, endpoints, tables)
- Implementation-ready (engineer can start immediately)
- Complete for Stage 4 (all required sections present)
- Addresses scalability and performance
- Includes monitoring and alerting plan
- Honest about what's being skipped (and why)

---

### Priority Framework

**P0 (Must Have):** Version control, comprehensive tests, error handling, logging, README, environment config, CI/CD, monitoring, security basics

**P1 (Should Have):** Architecture documentation, performance monitoring, automated deployments, alerting, on-call processes, security audits

**P2 (Nice to Have):** Advanced observability (distributed tracing), cost optimization, perfect test coverage, technical debt paydown

**At Stage 4, prioritize:**
- **P0 items:** Non-negotiable foundation for scaling
- **P1 items:** Invest in most of these - they become P0 as you grow
- **P2 items:** Nice to have, but don't block shipping on these

The gap between P0 and P1 is narrowing. Most P1 items should be done at Stage 4.

---

### Common Pitfalls to Avoid at Stage 4

**What to avoid:**
- ❌ No monitoring/observability plan
- ❌ No security considerations
- ❌ No performance requirements
- ❌ No rollout strategy
- ❌ Underestimating scale requirements
- ❌ Missing testing strategy (or <60% coverage goal)
- ❌ Manual deployment processes
- ❌ No on-call or incident response plan
- ❌ Ignoring technical debt (but don't over-invest in paydown either)
- ❌ Building for scale you don't have yet

**Remember:** You're scaling infrastructure and team. Invest in automation, monitoring, and processes that support growth. But don't over-engineer for theoretical scale - build for 10x your current scale, not 1000x.

---

*For complete details and cross-stage comparisons, see [production-criteria.md](./claude/production-criteria.md) or [.claude/production-criteria.md](./.claude/production-criteria.md)*

<!-- END: Stage-Specific Criteria -->

---

**Remember**: The golden rule is **atomic commits** - always commit code changes and issue status updates together!
